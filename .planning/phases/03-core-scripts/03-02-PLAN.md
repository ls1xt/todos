---
phase: 03-core-scripts
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - done
  - block
  - drop
autonomous: true
requirements:
  - SCPT-04
  - SCPT-05
  - SCPT-06
  - SCPT-07

must_haves:
  truths:
    - "`done <pattern>` moves the matched file from `open/` to `done/` and auto-commits with `done: <title>`"
    - "`block <pattern>` moves the matched file from `open/` to `blocked/` and auto-commits with `block: <title>`"
    - "`drop <pattern>` moves the matched file from `open/` to `dropped/` and auto-commits with `drop: <title>`"
    - "Zero matches: exits 1 and outputs a message containing \"no match\" to stdout/stderr"
    - "Multiple matches: exits 1, lists all matching filenames, moves nothing"
    - "Single match: moves file and commits, exits 0"
  artifacts:
    - path: "done"
      provides: "Bash script to mark a todo complete"
      min_lines: 30
    - path: "block"
      provides: "Bash script to mark a todo blocked"
      min_lines: 30
    - path: "drop"
      provides: "Bash script to mark a todo dropped"
      min_lines: 30
  key_links:
    - from: "done/block/drop"
      to: "open/<pattern>*.md"
      via: "glob match on open/ filenames using substring pattern"
      pattern: "open/\\*"
    - from: "done/block/drop"
      to: "done|blocked|dropped directory"
      via: "mv + git add + git commit"
      pattern: "git commit"
---

<objective>
Implement the `done`, `block`, and `drop` bash scripts at the repo root. Each script takes a pattern argument, finds exactly one matching file in `open/`, moves it to the target directory, and auto-commits. Handles zero-match and multiple-match error cases.

Purpose: Enables status transitions — marking a todo as done, blocked, or dropped with a single command.
Output: Three executable scripts (`done`, `block`, `drop`), all bats tests in `tests/done.bats`, `tests/block.bats`, `tests/drop.bats` passing.
</objective>

<execution_context>
@/home/leon/.claude/get-shit-done/workflows/execute-plan.md
@/home/leon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@tests/done.bats
@tests/block.bats
@tests/drop.bats
@tests/helpers/setup.bash
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement shared pattern-matching logic and write `done`, `block`, `drop` scripts</name>
  <files>done, block, drop</files>
  <action>
All three scripts share the same pattern-matching logic. The only differences are the target directory and commit message prefix.

**Pattern matching (from tests):**
- Search `open/` for files whose filename (not path) contains the pattern as a substring
- Use glob: `open/*${PATTERN}*` — but this may expand to nothing; use a loop or array
- Zero matches: print a message containing "no match" (tests check `--partial "no match"`), exit 1
- Multiple matches: print ALL matching filenames (tests check `--partial` for each), exit 1, move NOTHING
- Single match: move the file, commit, exit 0

**Git commit message format (from tests):**
- `done`: `done: <title>` — tests check `--partial "done:"`
- `block`: `block: <title>` — tests check `--partial "block:"`
- `drop`: `drop: <title>` — tests check `--partial "drop:"`
- Title = the filename without the leading date and without `.md` extension
  - Example: `2026-01-01-fix-bug.md` → title = `fix-bug` (strip `YYYY-MM-DD-` prefix, strip `.md` suffix)
  - Pattern: `basename "$FILE" .md | sed 's/^[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}-//'`

**Shared script template:**
```bash
#!/usr/bin/env bash
set -e

PATTERN="$1"
TARGET_DIR="<done|blocked|dropped>"
ACTION="<done|block|drop>"

if [[ -z "$PATTERN" ]]; then
  echo "Usage: $ACTION <pattern>" >&2
  exit 1
fi

# Find matches in open/
MATCHES=()
for f in open/*"${PATTERN}"*; do
  [[ -f "$f" ]] && MATCHES+=("$f")
done

if [[ ${#MATCHES[@]} -eq 0 ]]; then
  echo "no match: $PATTERN" >&2
  exit 1
fi

if [[ ${#MATCHES[@]} -gt 1 ]]; then
  echo "multiple matches:" >&2
  for m in "${MATCHES[@]}"; do
    echo "  $(basename "$m")" >&2
  done
  exit 1
fi

FILE="${MATCHES[0]}"
FILENAME="$(basename "$FILE")"
TITLE="$(echo "$FILENAME" | sed 's/\.md$//' | sed 's/^[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}-//')"

mv "$FILE" "${TARGET_DIR}/${FILENAME}"
git add "${TARGET_DIR}/${FILENAME}"
git add "$FILE" 2>/dev/null || true   # stage the removal (in case git doesn't track the mv automatically)
git rm --cached "$FILE" 2>/dev/null || true  # remove old path from index if still tracked
git add "${TARGET_DIR}/${FILENAME}"
git commit -m "${ACTION}: ${TITLE}"
```

**Important notes on git mv vs plain mv:**
- The tests use a temp git repo with files committed to `open/`
- After `mv`, the old path needs to be removed from the index and new path added
- Simplest approach that works: use `git mv "open/$FILENAME" "${TARGET_DIR}/$FILENAME"` instead of plain `mv` — this atomically handles both removal and addition in the index
- Revised script core:
  ```bash
  git mv "$FILE" "${TARGET_DIR}/${FILENAME}"
  git commit -m "${ACTION}: ${TITLE}"
  ```
- Use `git mv` in all three scripts for clean index management

**Write each script:**

1. `done` — TARGET_DIR=`done`, ACTION=`done`
2. `block` — TARGET_DIR=`blocked`, ACTION=`block`
3. `drop` — TARGET_DIR=`dropped`, ACTION=`drop`

Write each file with the Write tool (do NOT use Bash heredoc/cat).
After writing all three, run:
```bash
chmod +x done block drop
```

**Verify error output reaches the test:** The tests use `assert_output --partial "no match"` against the `$output` variable which bats captures from both stdout and stderr. Writing errors to stderr (`>&2`) is fine and conventional — bats captures both streams in `$output`.

For the multiple matches case, the tests check `assert_output --partial "fix-bug-alpha"` — print the full basename or just the slug portion, as long as the pattern is present. Printing basenames is safest.
  </action>
  <verify>
    <automated>cd /home/leon/todos && ./tests/libs/bats-core/bin/bats tests/done.bats tests/block.bats tests/drop.bats</automated>
    <manual>All 12 tests (4 per script) should pass: move, commit message, zero-match error, multiple-match listing.</manual>
  </verify>
  <done>
    `./tests/libs/bats-core/bin/bats tests/done.bats tests/block.bats tests/drop.bats` reports 12 tests, 0 failures.
    Files `done`, `block`, `drop` exist at repo root, are executable.
  </done>
</task>

</tasks>

<verification>
Run all three test suites:
```bash
./tests/libs/bats-core/bin/bats tests/done.bats tests/block.bats tests/drop.bats
```
Expected: 12 passed, 0 failed.

Also run the combined core script suite:
```bash
./tests/libs/bats-core/bin/bats tests/add.bats tests/done.bats tests/block.bats tests/drop.bats
```
Expected: 21 passed, 0 failed.

Spot-check executability:
```bash
ls -la done block drop    # all should show executable bit
```
</verification>

<success_criteria>
- `done`, `block`, `drop` scripts exist at repo root, all executable
- All 12 tests in tests/done.bats + tests/block.bats + tests/drop.bats pass
- SCPT-04: `done <pattern>` moves file to `done/` and commits with `done: <title>`
- SCPT-05: `block <pattern>` moves file to `blocked/` and commits with `block: <title>`
- SCPT-06: `drop <pattern>` moves file to `dropped/` and commits with `drop: <title>`
- SCPT-07: Zero matches exits 1 + "no match" message; multiple matches exits 1 + lists all candidates + moves nothing
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-scripts/03-02-SUMMARY.md` with what was built, any decisions made, and the test result.
</output>
